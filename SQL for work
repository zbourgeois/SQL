-SQL I use in my career. From basic updates to selecting useful information from multiple tables.


--View Tables;
SHOW TABLES;

--Show all columns we can access;
select table_catalog, table_schema, table_name, column_name
from information_schema.columns
where table_schema = 'PUBLIC'
order by table_name;


--Count indication types;
select it.Label as IndicationType,count(i.id) as Count
from indication i, indicationtype it
where  i.IndicationType=it.Id and deleted = false
group by indicationtype;


--Update Bend Dees;
UPDATE bend
SET diameters = '3.0'
WHERE diameters = '8.0';

--Update Bend Angle to 90 where >90 (MPLX);
UPDATE bend
SET angle = '90'
WHERE angle > 90;

--Update Feature Comments;
UPDATE feature
SET comment='Repaired?' 
WHERE featuretype='Attachment';

--Remove Feature Comments;
UPDATE feature
SET comment = NULL
WHERE comment LIKE '%Bag%';


--Remove orientations for features;
UPDATE feature
SET orientation=NULL 
WHERE featuretype='Anchor’;

--Remove CSNs;
UPDATE eventheader
SET customerstation=NULL
WHERE customerstation like '%+%';

--Set orientations for Attachments without orientation;
Update feature
SET orientation = '0'
WHERE featuretype = 'Attachment'
AND orientation = '999';

--Swap cursor placement;
UPDATE eventheader eh
SET eh.leftcursorposition = eh.rightcursorposition,
eh.rightcursorposition = eh.leftcursorposition
WHERE rightcursorposition < leftcursorposition;

--See features with cursors on same sample;
SELECT *
FROM eventheader eh
	JOIN feature f
	ON eh.sampleindex = f.sampleindex
WHERE leftcursorposition = rightcursorposition
AND featuretype IS NOT NULL;




--Shows difference between left and right cursor. (features);
	--Negative number means cursors are backwards.
SELECT ed.SampleIndex,EnduroStation,ProjectedStation,Label,FeatureType,casewhen(Orientation=999,null,Orientation) as FOrientation , sum(rightcursorposition - leftcursorposition) AS Cursor_Diff
FROM EventDetail ed, EventHeader eh,Feature f
WHERE ed.EventType=5 AND eh.SampleIndex=ed.SampleIndex AND f.SampleIndex=ed.SampleIndex GROUP BY eh.sampleindex;



--Update Pipe Construction comments;
UPDATE pipeconstruction
SET comment='Change to ERW' 
WHERE constructtype= 4;

--Change Pipe Constructions;
UPDATE pipeconstruction
SET constructtype = '11'
WHERE constructtype = '4';

ID	Label		
1	SW		
2	Seamless		
3	Spiral		
4	ERW		
5	SAW		
6	DSAW		
7	Lap		
8	LF-ERW		
9	EFW		
10	Unknown		
11	HF-ERW		



--Update GPS source type from Enduro Survey to Customer Supplied;
update gps
set gpssourcetypeid = '3'
where gpssourcetypeid = '0';


--Shows wall thicknesses and spans;
SELECT DISTINCT round(WallThickness,3) as WT, SUM(round(Span,2)) as Span
FROM WallChange w
GROUP BY WallThickness
ORDER BY Span DESC;

--Update year installed;
UPDATE wallchange
SET yearinstalled = ‘2007’
WHERE sampleindex < 22352566;

--Update WT to customer supplied if year is supplied;
UPDATE wallchange
SET entrytype = 1
WHERE yearinstalled > 1;



--Update WT to enduro predicted if year is supplied;
UPDATE wallchange
SET entrytype = 2
WHERE yearinstalled < 1;

--Count Metal Loss for each Depth % sorted with highest depths first;
select maxdepth, count(maxdepth) as quantity
from indication where indicationtype = 2  group by maxdepth order by maxdepth desc;

--Show Flanges that are on the same sample as a weld;
SELECT f.sampleindex AS Feature_Sample, w.sampleindex AS Weld_Sample, featuretype
FROM feature f, weld w
WHERE featuretype = 'Flange'
AND f.sampleindex = w.sampleindex
GROUP BY f.sampleindex;





--Show wall thickness, pipe grade, and pipe construction;
select p.sampleindex, p.span as ConstructSpan, w.sampleindex, round(WallThickness,3) as WT, round(w.Span,2) as WTSpanLength, pg.sampleindex, smys, pct.label as ContstructType
from PipeConstruction p
join PipeConstructType pct on p.constructtype=pct.id
join pipegrade pg on pg.sampleindex = p.sampleindex
join wallchange w on w.sampleindex = p.sampleindex
join WallChangeEntryType et on w.entryType=et.id;



--Update both cursors at the same time;
update eventheader eh set leftcursorposition=(select sampleindex-9 from feature where featuretype='Cadweld' and sampleindex=eh.sampleindex) where eh.sampleindex in (select sampleindex from feature WHERE featuretype='Cadweld');
update eventheader eh set rightcursorposition=(select sampleindex+9 from feature where featuretype='Cadweld' and sampleindex=eh.sampleindex) where eh.sampleindex in (select sampleindex from feature WHERE featuretype='Cadweld');

--Update feature cursors based on current cursor position;
-LEFT CURSOR;
update eventheader eh
set leftcursorposition = leftcursorposition + 175
where eh.sampleindex in (select sampleindex from feature WHERE featuretype='Anchor');

-RIGHT CURSOR;
update eventheader eh
set rightcursorposition = rightcursorposition - 175
where eh.sampleindex in (select sampleindex from feature WHERE featuretype='Anchor');



--Move left cursor to include kickout on bends;
update eventheader eh
set leftcursorposition=(select leftcursorposition-100 from bend where diameters <12 and sampleindex=eh.sampleindex)
where eh.sampleindex in (select sampleindex from bend WHERE diameters < 12);


--Delete replacements from feature table and eventdetail table but keeps eventheader;
select * from eventdetail where label like 'F%';
delete from eventdetail ed
where ed.sampleindex in (select sampleindex from feature where featuretype like '%Replacement');
update feature
set deleted = true
where featuretype like '%Replacement';

--Change sleeves to weld reinforements between two sample numbers;

update feature
set featuretype = 'Weld Reinforcement'
where featuretype = 'Sleeve'
AND sampleindex BETWEEN 17986298 and 18035581;



--Select GPS that isn’t on a weld or AGM;
select *
from eventdetail ed
left join weld w
on w.sampleindex = ed.sampleindex
left join agm a
on a.sampleindex = ed.sampleindex
where label like 'G%'
and w.sampleindex is null
and a.customerlabel is null ;


--Update all GPS to ‘Customer Supplied’;
UPDATE GPS
SET gpssourcetypeid = 3
WHERE deleted = 'false';

ID	SOURCETYPE
0	Enduro Survey
1	Projected
2	AGM Box
3	Customer Supplied
4	Corrected
5	PigNavi


--Remove Box comment on AGMs;
update agm
set comment = null
where comment like 'Box%';

--Replace commas with semi-colons on AGMs (MPLX);
UPDATE agm
SET Comment = REPLACE(Comment, ',', char(59));


--Show bends that have a weld logged between cursors (sloppy looking);
select distinct b.sampleindex, eh.endurostation, ed.label, round(Angle,1) as BendAngle, round(Diameters,1) as Dees, round(Direction,1) as Dir, comment, leftcursorposition, rightcursorposition,b.username,b.modifieddate
from bend b, weld w
join eventheader eh on b.sampleindex = eh.sampleindex
join eventdetail ed on b.sampleindex = ed.sampleindex
where  diameters > 12 and b.deleted = 'false' and w.sampleindex > eh.leftcursorposition and w.sampleindex < eh.rightcursorposition order by b.sampleindex;

--Change AGM labels but keep number;
---Top query to update AGM label. Bottom query to update chart label;
update agm
set customerlabel = replace(customerlabel, 'AGM', 'MLV')
where customerlabel like 'AGM 10__';

update eventdetail
set label = replace(label, 'AGM', 'MLV')
where label like 'AGM 10__';


--Move all welds by sample;
----(Do not run if anything else is placed on weld samples. This moves everything on a sample because of the eventheader.);
update eventheader eh
set sampleindex = (select sampleindex +100 from eventdetail where label = 'Weld' and sampleindex = eh.sampleindex) where eh.sampleindex in (select sampleindex from eventdetail where label = 'Weld');

update weld
set sampleindex = (sampleindex + 100);

update eventdetail
set sampleindex = (sampleindex + 100)
where label = 'Weld';

update eventheader eh
set leftcursorposition = sampleindex - 5
where sampleindex in (select sampleindex from eventdetail where label = 'Weld');

update eventheader eh
set rightcursorposition = sampleindex + 5
where sampleindex in (select sampleindex from eventdetail where label = 'Weld');



--Update Phillips 66 AGMs to AGRs;
update agm
set customerlabel = replace(customerlabel,'AGM','AGR')
where customerlabel like 'AGM%';
update agm
set comment = replace(comment,'AGM','AGR');
update eventdetail
set label = replace(label,'AGM','AGR')
where label like 'AGM%';


--Update AGM comments between samples and concat label with description;
update agm
set comment = concat(customerlabel, ', AGM STAKE')
where sampleindex > 3135130 and sampleindex < 4681955
and deleted = false;


--Compare correlated depth %s sorted with highest difference first;
select i.sampleindex,ed.label,dc.foreignid,dc.foreigndesc,round(dc.orientation,0) as clock,round(dc.length,2) as f_length,round(dc.width,2) as f_width,round(dc.depth,0) as f_depth,it.label as indicationtype,ist.label as indicationsubtype,round(i.length,2) as length,round(i.width,2) as width,round(i.maxdepth,2) as depth,round(abs(dc.depth - i.maxdepth),2) as percent_diff
from defectcorrelation dc,indicationtype it, indicationsubtype ist
join indication i on i.id = dc.indicationid
join eventdetail ed on i.sampleindex = ed.sampleindex
where i.indicationtype=it.Id and i.indicationsubtype=ist.id
and ed.label not like 'S%'
order by percent_diff desc;



--Update Buckeye comments to only include AGM label and Station;
update agm a
set comment = case
when (select eh.customerstation from eventheader eh where customerstation like '%+%' and eh.sampleindex = a.sampleindex) like '%+%' then concat(customerlabel,', ',(select customerstation from eventheader eh where customerstation like '%+%' and eh.sampleindex = a.sampleindex))
else customerlabel
end
where a.customerlabel is not null;


--Select ML depth count from correlation;
select depth, count(depth) as count from defectcorrelation
where indicationtype = 2
group by depth
order by depth desc;



--Calculate bend dees;
select distinct b.sampleindex as bend, (select leftcursorposition from eventheader eh where eh.sampleindex=b.sampleindex) as leftcursor, (select rightcursorposition from eventheader eh where eh.sampleindex=b.sampleindex) as rightcursor, round((((((select min(sampleindex) from weld w where w.sampleindex > b.sampleindex and deleted = false) -  (select max(sampleindex) from weld w where w.sampleindex < b.sampleindex and deleted = false)) /10)*(360/(2*PI())))/((select pipediameter from rundata)*b.angle)),2) as calculated_dees,
diameters as current_dees, round(abs(round((((((select min(sampleindex) from weld w where w.sampleindex > b.sampleindex and deleted = false) -  (select max(sampleindex) from weld w where w.sampleindex < b.sampleindex and deleted = false)) /10)*(360/(2*PI())))/((select pipediameter from rundata)*b.angle)),2) - diameters),2) as difference
from weld w, bend b
where diameters < 12 and b.deleted = false
order by difference desc;

--------Calculate bend dees (less information, but runs faster);
select distinct b.sampleindex as bend, round((((((select min(sampleindex) from weld w where w.sampleindex > b.sampleindex and deleted = false) -  (select max(sampleindex) from weld w where w.sampleindex < b.sampleindex and deleted = false)) /10)*(360/(2*PI())))/((select pipediameter from rundata)*b.angle)),2) as calculated_dees,
diameters as current_dees
from weld w, bend b
where diameters < 12 and b.deleted = false
order by b.sampleindex;

--Finds induction bends (runs slow);
-----Searches for cursors inside welds on factory bends;
select distinct b.sampleindex
from bend b, weld w
join eventheader eh on w.sampleindex = eh.sampleindex
where ((select max(sampleindex) from weld w where w.sampleindex < b.sampleindex) < (select leftcursorposition from eventheader eh where eh.sampleindex = b.sampleindex)) or 
((select min(sampleindex) from weld w where w.sampleindex > b.sampleindex) > (select rightcursorposition from eventheader eh where sampleindex = b.sampleindex))
group by b.sampleindex
having diameters < 12 and b.deleted = false;


--Selects all uncorrelated indications from previous job (does not float to correct orientation);
select upstreamweldindex + distancetoweld*120 as index, round(orientation,2) as orientation, foreignid,it.label as indicationtype, foreigndesc, round(length,2) as length, round(width,2) as width, round(depth,2) as depth,  distancetoweld
from defectcorrelation dc, indicationtype it
where indicationtype = it.id
and indicationid is null
order by it.label;



--select sample distance from indication to star ;
select i.sampleindex,abs((dc.upstreamweldindex + dc.origdistancetoweld*120) - i.sampleindex) as sampdist,  round(i.orientation,2) as orientation, foreignid, it.label as indicationtype, foreigndesc, round(i.length,2) as length, round(i.width,2) as width, round(i.maxdepth,2) as depth,  round(distancetoweld,2) as distancetoweld
from defectcorrelation dc,indicationtype it
join indication i on dc.indicationid = i.id
where distancetoweld < 120 and i.indicationtype = it.id
order by sampdist desc;

--Selects caliper depth for calling surfaces sorted with most caliper depth at the top;
select i.sampleindex, ed.label, it.Label as IndicationType,ist.Label as IndicationSubType,s.Label as Surface, i.maxdepth, round((caliperdepth/wt)*100,2) as caliper, foreigndesc, dc.depth as foreigndepth, round(dc.orientation,0) as foreignclock
from defectcrossreference dcr, indicationtype it, indicationsubtype ist, surface s
join indication i on i.sampleindex = dcr.sampleindex
join eventdetail ed on ed.sampleindex = dcr.sampleindex
left join defectcorrelation dc on i.id = dc.indicationid
where i.indicationtype = 2 AND i.IndicationType=it.Id AND i.IndicationSubType=ist.Id AND i.Surface=s.id and i.deleted = false and ed.label like 'L%'
order by caliper desc;

--Bend direction as text;
select sampleindex, direction as degrees,
case
	when direction between 45 and 135 then 'Right'
	when direction between 135.01 and 225.01 then 'Down'
	when direction between 225 and 315 then 'Left'
	else 'Up'
end as direction,
diameters as dees
from bend;

End of job counts
--Select minimum and maximum dent depth;
select round(min((maxdepth / (select pipediameter from rundata))*100),2) as "MIN_DENT_%", round(max((maxdepth / (select pipediameter from rundata))*100),2) as "MAX_DENT_%"
from indication where indicationtype = 1 and deleted = 'false';

--Shows difference between previous ML and current ML and how many are linked;
select (select count(indicationtype) from indication where indicationtype = 2 and deleted = 'false') as current_ml, (select count(indicationtype) from defectcorrelation where indicationtype = 2) as prev_ml, count(dc.indicationid) as linked, (select count(dc.indicationid) from defectcorrelation where indicationid is null and indicationtype=2) as unlinked
from defectcorrelation dc
where indicationid >=1 and indicationtype = 2;

--Count Metal Loss for each Depth % sorted with highest depths first;
select distinct(maxdepth) as "DEPTH%", count(maxdepth) as count
from indication
where indicationtype = 2 and deleted = 'false'
group by maxdepth
order by maxdepth desc;

--Shows current and previous indication counts;
select label, (select count(indicationtype) from indication where indicationtype = it.id and deleted = 'false') as current,  (select count(indicationtype) from defectcorrelation where indicationtype = it.id) as previous
from indicationtype it;
